// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.1
// - protoc             v6.33.1
// source: catalog/v1/catalog.proto

package catalogv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	CatalogService_GetEpisodesByIDs_FullMethodName           = "/catalog.v1.CatalogService/GetEpisodesByIDs"
	CatalogService_GetProviderEpisodeID_FullMethodName       = "/catalog.v1.CatalogService/GetProviderEpisodeID"
	CatalogService_GetAnimeByIDs_FullMethodName              = "/catalog.v1.CatalogService/GetAnimeByIDs"
	CatalogService_GetAnimeIDs_FullMethodName                = "/catalog.v1.CatalogService/GetAnimeIDs"
	CatalogService_GetEpisodesByAnimeID_FullMethodName       = "/catalog.v1.CatalogService/GetEpisodesByAnimeID"
	CatalogService_UpsertAnimeKaiAnime_FullMethodName        = "/catalog.v1.CatalogService/UpsertAnimeKaiAnime"
	CatalogService_AttachExternalAnimeID_FullMethodName      = "/catalog.v1.CatalogService/AttachExternalAnimeID"
	CatalogService_ResolveAnimeIDByExternalID_FullMethodName = "/catalog.v1.CatalogService/ResolveAnimeIDByExternalID"
	CatalogService_UpsertHiAnimeEpisodes_FullMethodName      = "/catalog.v1.CatalogService/UpsertHiAnimeEpisodes"
	CatalogService_UpsertJikanAnime_FullMethodName           = "/catalog.v1.CatalogService/UpsertJikanAnime"
)

// CatalogServiceClient is the client API for CatalogService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CatalogServiceClient interface {
	GetEpisodesByIDs(ctx context.Context, in *GetEpisodesByIDsRequest, opts ...grpc.CallOption) (*GetEpisodesByIDsResponse, error)
	GetProviderEpisodeID(ctx context.Context, in *GetProviderEpisodeIDRequest, opts ...grpc.CallOption) (*GetProviderEpisodeIDResponse, error)
	GetAnimeByIDs(ctx context.Context, in *GetAnimeByIDsRequest, opts ...grpc.CallOption) (*GetAnimeByIDsResponse, error)
	GetAnimeIDs(ctx context.Context, in *GetAnimeIDsRequest, opts ...grpc.CallOption) (*GetAnimeIDsResponse, error)
	GetEpisodesByAnimeID(ctx context.Context, in *GetEpisodesByAnimeIDRequest, opts ...grpc.CallOption) (*GetEpisodesByAnimeIDResponse, error)
	UpsertAnimeKaiAnime(ctx context.Context, in *UpsertAnimeKaiAnimeRequest, opts ...grpc.CallOption) (*UpsertAnimeKaiAnimeResponse, error)
	AttachExternalAnimeID(ctx context.Context, in *AttachExternalAnimeIDRequest, opts ...grpc.CallOption) (*AttachExternalAnimeIDResponse, error)
	ResolveAnimeIDByExternalID(ctx context.Context, in *ResolveAnimeIDByExternalIDRequest, opts ...grpc.CallOption) (*ResolveAnimeIDByExternalIDResponse, error)
	UpsertHiAnimeEpisodes(ctx context.Context, in *UpsertHiAnimeEpisodesRequest, opts ...grpc.CallOption) (*UpsertHiAnimeEpisodesResponse, error)
	UpsertJikanAnime(ctx context.Context, in *UpsertJikanAnimeRequest, opts ...grpc.CallOption) (*UpsertJikanAnimeResponse, error)
}

type catalogServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCatalogServiceClient(cc grpc.ClientConnInterface) CatalogServiceClient {
	return &catalogServiceClient{cc}
}

func (c *catalogServiceClient) GetEpisodesByIDs(ctx context.Context, in *GetEpisodesByIDsRequest, opts ...grpc.CallOption) (*GetEpisodesByIDsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetEpisodesByIDsResponse)
	err := c.cc.Invoke(ctx, CatalogService_GetEpisodesByIDs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *catalogServiceClient) GetProviderEpisodeID(ctx context.Context, in *GetProviderEpisodeIDRequest, opts ...grpc.CallOption) (*GetProviderEpisodeIDResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProviderEpisodeIDResponse)
	err := c.cc.Invoke(ctx, CatalogService_GetProviderEpisodeID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *catalogServiceClient) GetAnimeByIDs(ctx context.Context, in *GetAnimeByIDsRequest, opts ...grpc.CallOption) (*GetAnimeByIDsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAnimeByIDsResponse)
	err := c.cc.Invoke(ctx, CatalogService_GetAnimeByIDs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *catalogServiceClient) GetAnimeIDs(ctx context.Context, in *GetAnimeIDsRequest, opts ...grpc.CallOption) (*GetAnimeIDsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAnimeIDsResponse)
	err := c.cc.Invoke(ctx, CatalogService_GetAnimeIDs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *catalogServiceClient) GetEpisodesByAnimeID(ctx context.Context, in *GetEpisodesByAnimeIDRequest, opts ...grpc.CallOption) (*GetEpisodesByAnimeIDResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetEpisodesByAnimeIDResponse)
	err := c.cc.Invoke(ctx, CatalogService_GetEpisodesByAnimeID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *catalogServiceClient) UpsertAnimeKaiAnime(ctx context.Context, in *UpsertAnimeKaiAnimeRequest, opts ...grpc.CallOption) (*UpsertAnimeKaiAnimeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpsertAnimeKaiAnimeResponse)
	err := c.cc.Invoke(ctx, CatalogService_UpsertAnimeKaiAnime_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *catalogServiceClient) AttachExternalAnimeID(ctx context.Context, in *AttachExternalAnimeIDRequest, opts ...grpc.CallOption) (*AttachExternalAnimeIDResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AttachExternalAnimeIDResponse)
	err := c.cc.Invoke(ctx, CatalogService_AttachExternalAnimeID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *catalogServiceClient) ResolveAnimeIDByExternalID(ctx context.Context, in *ResolveAnimeIDByExternalIDRequest, opts ...grpc.CallOption) (*ResolveAnimeIDByExternalIDResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResolveAnimeIDByExternalIDResponse)
	err := c.cc.Invoke(ctx, CatalogService_ResolveAnimeIDByExternalID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *catalogServiceClient) UpsertHiAnimeEpisodes(ctx context.Context, in *UpsertHiAnimeEpisodesRequest, opts ...grpc.CallOption) (*UpsertHiAnimeEpisodesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpsertHiAnimeEpisodesResponse)
	err := c.cc.Invoke(ctx, CatalogService_UpsertHiAnimeEpisodes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *catalogServiceClient) UpsertJikanAnime(ctx context.Context, in *UpsertJikanAnimeRequest, opts ...grpc.CallOption) (*UpsertJikanAnimeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpsertJikanAnimeResponse)
	err := c.cc.Invoke(ctx, CatalogService_UpsertJikanAnime_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CatalogServiceServer is the server API for CatalogService service.
// All implementations must embed UnimplementedCatalogServiceServer
// for forward compatibility.
type CatalogServiceServer interface {
	GetEpisodesByIDs(context.Context, *GetEpisodesByIDsRequest) (*GetEpisodesByIDsResponse, error)
	GetProviderEpisodeID(context.Context, *GetProviderEpisodeIDRequest) (*GetProviderEpisodeIDResponse, error)
	GetAnimeByIDs(context.Context, *GetAnimeByIDsRequest) (*GetAnimeByIDsResponse, error)
	GetAnimeIDs(context.Context, *GetAnimeIDsRequest) (*GetAnimeIDsResponse, error)
	GetEpisodesByAnimeID(context.Context, *GetEpisodesByAnimeIDRequest) (*GetEpisodesByAnimeIDResponse, error)
	UpsertAnimeKaiAnime(context.Context, *UpsertAnimeKaiAnimeRequest) (*UpsertAnimeKaiAnimeResponse, error)
	AttachExternalAnimeID(context.Context, *AttachExternalAnimeIDRequest) (*AttachExternalAnimeIDResponse, error)
	ResolveAnimeIDByExternalID(context.Context, *ResolveAnimeIDByExternalIDRequest) (*ResolveAnimeIDByExternalIDResponse, error)
	UpsertHiAnimeEpisodes(context.Context, *UpsertHiAnimeEpisodesRequest) (*UpsertHiAnimeEpisodesResponse, error)
	UpsertJikanAnime(context.Context, *UpsertJikanAnimeRequest) (*UpsertJikanAnimeResponse, error)
	mustEmbedUnimplementedCatalogServiceServer()
}

// UnimplementedCatalogServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCatalogServiceServer struct{}

func (UnimplementedCatalogServiceServer) GetEpisodesByIDs(context.Context, *GetEpisodesByIDsRequest) (*GetEpisodesByIDsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetEpisodesByIDs not implemented")
}
func (UnimplementedCatalogServiceServer) GetProviderEpisodeID(context.Context, *GetProviderEpisodeIDRequest) (*GetProviderEpisodeIDResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetProviderEpisodeID not implemented")
}
func (UnimplementedCatalogServiceServer) GetAnimeByIDs(context.Context, *GetAnimeByIDsRequest) (*GetAnimeByIDsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAnimeByIDs not implemented")
}
func (UnimplementedCatalogServiceServer) GetAnimeIDs(context.Context, *GetAnimeIDsRequest) (*GetAnimeIDsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAnimeIDs not implemented")
}
func (UnimplementedCatalogServiceServer) GetEpisodesByAnimeID(context.Context, *GetEpisodesByAnimeIDRequest) (*GetEpisodesByAnimeIDResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetEpisodesByAnimeID not implemented")
}
func (UnimplementedCatalogServiceServer) UpsertAnimeKaiAnime(context.Context, *UpsertAnimeKaiAnimeRequest) (*UpsertAnimeKaiAnimeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpsertAnimeKaiAnime not implemented")
}
func (UnimplementedCatalogServiceServer) AttachExternalAnimeID(context.Context, *AttachExternalAnimeIDRequest) (*AttachExternalAnimeIDResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AttachExternalAnimeID not implemented")
}
func (UnimplementedCatalogServiceServer) ResolveAnimeIDByExternalID(context.Context, *ResolveAnimeIDByExternalIDRequest) (*ResolveAnimeIDByExternalIDResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ResolveAnimeIDByExternalID not implemented")
}
func (UnimplementedCatalogServiceServer) UpsertHiAnimeEpisodes(context.Context, *UpsertHiAnimeEpisodesRequest) (*UpsertHiAnimeEpisodesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpsertHiAnimeEpisodes not implemented")
}
func (UnimplementedCatalogServiceServer) UpsertJikanAnime(context.Context, *UpsertJikanAnimeRequest) (*UpsertJikanAnimeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpsertJikanAnime not implemented")
}
func (UnimplementedCatalogServiceServer) mustEmbedUnimplementedCatalogServiceServer() {}
func (UnimplementedCatalogServiceServer) testEmbeddedByValue()                        {}

// UnsafeCatalogServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CatalogServiceServer will
// result in compilation errors.
type UnsafeCatalogServiceServer interface {
	mustEmbedUnimplementedCatalogServiceServer()
}

func RegisterCatalogServiceServer(s grpc.ServiceRegistrar, srv CatalogServiceServer) {
	// If the following call panics, it indicates UnimplementedCatalogServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CatalogService_ServiceDesc, srv)
}

func _CatalogService_GetEpisodesByIDs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEpisodesByIDsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CatalogServiceServer).GetEpisodesByIDs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CatalogService_GetEpisodesByIDs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CatalogServiceServer).GetEpisodesByIDs(ctx, req.(*GetEpisodesByIDsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CatalogService_GetProviderEpisodeID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProviderEpisodeIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CatalogServiceServer).GetProviderEpisodeID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CatalogService_GetProviderEpisodeID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CatalogServiceServer).GetProviderEpisodeID(ctx, req.(*GetProviderEpisodeIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CatalogService_GetAnimeByIDs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAnimeByIDsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CatalogServiceServer).GetAnimeByIDs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CatalogService_GetAnimeByIDs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CatalogServiceServer).GetAnimeByIDs(ctx, req.(*GetAnimeByIDsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CatalogService_GetAnimeIDs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAnimeIDsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CatalogServiceServer).GetAnimeIDs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CatalogService_GetAnimeIDs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CatalogServiceServer).GetAnimeIDs(ctx, req.(*GetAnimeIDsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CatalogService_GetEpisodesByAnimeID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEpisodesByAnimeIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CatalogServiceServer).GetEpisodesByAnimeID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CatalogService_GetEpisodesByAnimeID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CatalogServiceServer).GetEpisodesByAnimeID(ctx, req.(*GetEpisodesByAnimeIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CatalogService_UpsertAnimeKaiAnime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpsertAnimeKaiAnimeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CatalogServiceServer).UpsertAnimeKaiAnime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CatalogService_UpsertAnimeKaiAnime_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CatalogServiceServer).UpsertAnimeKaiAnime(ctx, req.(*UpsertAnimeKaiAnimeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CatalogService_AttachExternalAnimeID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttachExternalAnimeIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CatalogServiceServer).AttachExternalAnimeID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CatalogService_AttachExternalAnimeID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CatalogServiceServer).AttachExternalAnimeID(ctx, req.(*AttachExternalAnimeIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CatalogService_ResolveAnimeIDByExternalID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResolveAnimeIDByExternalIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CatalogServiceServer).ResolveAnimeIDByExternalID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CatalogService_ResolveAnimeIDByExternalID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CatalogServiceServer).ResolveAnimeIDByExternalID(ctx, req.(*ResolveAnimeIDByExternalIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CatalogService_UpsertHiAnimeEpisodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpsertHiAnimeEpisodesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CatalogServiceServer).UpsertHiAnimeEpisodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CatalogService_UpsertHiAnimeEpisodes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CatalogServiceServer).UpsertHiAnimeEpisodes(ctx, req.(*UpsertHiAnimeEpisodesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CatalogService_UpsertJikanAnime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpsertJikanAnimeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CatalogServiceServer).UpsertJikanAnime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CatalogService_UpsertJikanAnime_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CatalogServiceServer).UpsertJikanAnime(ctx, req.(*UpsertJikanAnimeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CatalogService_ServiceDesc is the grpc.ServiceDesc for CatalogService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CatalogService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "catalog.v1.CatalogService",
	HandlerType: (*CatalogServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetEpisodesByIDs",
			Handler:    _CatalogService_GetEpisodesByIDs_Handler,
		},
		{
			MethodName: "GetProviderEpisodeID",
			Handler:    _CatalogService_GetProviderEpisodeID_Handler,
		},
		{
			MethodName: "GetAnimeByIDs",
			Handler:    _CatalogService_GetAnimeByIDs_Handler,
		},
		{
			MethodName: "GetAnimeIDs",
			Handler:    _CatalogService_GetAnimeIDs_Handler,
		},
		{
			MethodName: "GetEpisodesByAnimeID",
			Handler:    _CatalogService_GetEpisodesByAnimeID_Handler,
		},
		{
			MethodName: "UpsertAnimeKaiAnime",
			Handler:    _CatalogService_UpsertAnimeKaiAnime_Handler,
		},
		{
			MethodName: "AttachExternalAnimeID",
			Handler:    _CatalogService_AttachExternalAnimeID_Handler,
		},
		{
			MethodName: "ResolveAnimeIDByExternalID",
			Handler:    _CatalogService_ResolveAnimeIDByExternalID_Handler,
		},
		{
			MethodName: "UpsertHiAnimeEpisodes",
			Handler:    _CatalogService_UpsertHiAnimeEpisodes_Handler,
		},
		{
			MethodName: "UpsertJikanAnime",
			Handler:    _CatalogService_UpsertJikanAnime_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "catalog/v1/catalog.proto",
}
